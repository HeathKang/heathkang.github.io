---
layout: post
title:  "查找"
subtitle: "常用查找算法和数据结构"
date:   2018-11-22 21:00:05 -0400
background: '/img/posts/sort/sort.jpg'
categories: Programming
---
## 序列化查找
#### 思路
顺序地搜索链表查找给定的键。
#### 实现
nim代码实现：
```
import options


type 
    SequentialSearchST* = ref object of RootObj
        first: Node

    Node* = ref object of RootObj 
        key:string
        value:int
        next:Node

    
proc get*(st:SequentialSearchST,key:string) :Option[int] = 
    var st_node: Node = st.first
    while st_node != nil:
        if key == st_node.key:
            return some(st_node.value)
        else:
            st_node = st_node.next

proc put*(st:SequentialSearchST,key:string, value:int) =
    var st_node: Node = st.first
    while st_node != nil:
        if key == st_node.key:
            st_node.value = value
        break
    
    st.first = Node(key: key, value: value, next: st.first)
    
proc main() = 
    var 
        node = Node(key: "S", value: 0, next:nil)
        st = SequentialSearchST(first: node)
    st.put("E", 1)
    echo "S"
    echo st.get("E")

main()
```
## 二分查找
#### 思路
分别将key和value做成有序队列，插入和查找时，用二分查找的方式迅速定位键的有序顺序位置，然后进行get或put操作
#### 实现
```
nim代码实现：
import options

type 
    BinarySearchST* = ref object of RootObj
        keys: seq[string]
        vals: seq[int]
        N: int

proc size*(bt: BinarySearchST): int = 
    return bt.N

proc rank*(bt: BinarySearchST, key: string): int = 
    var
        lo = 0
        hi = bt.N - 1
        mid = 0

    while lo <= hi:
        mid = lo + (hi - lo) div 2
        if key < bt.keys[mid]:
            hi = mid - 1
        elif key > bt.keys[mid]:
            lo = mid + 1
        else:
            return mid
    return lo

proc get*(bt: BinarySearchST, key: string): Option[int] = 
    var i:int = bt.rank(key)
    if i < bt.N and bt.keys[i] == key:
        return some(bt.vals[i])
    else:
        return none(int)

proc put*(bt: BinarySearchST, key: string, val:int) = 
    var i:int = bt.rank(key)
    # key is already in keys
    if i < bt.N and bt.keys[i] == key:
        bt.vals[i] = val
        return
    # add key and val in proper location
    var j:int = bt.N
    # add keys and vals length
    bt.keys.add("")
    bt.vals.add(0)
    while j > i:
        bt.keys[j] = bt.keys[j - 1]
        bt.vals[j] = bt.vals[j - 1]
        j = j - 1

    bt.keys[i] = key
    bt.vals[i] = val
    bt.N = bt.N + 1
```
其中的rank算法，即二分查找是关键，能将查询时间缩减到logN

## 二叉查找树
#### 思路
可以将**链表插入的灵活性**和**有序数组查找的高效性**结合起来的符号表实现。即实现一个树结构，树左侧键<树右侧键，这样查找和插入将很快找到位置。
#### 实现
```
import options


type
    BST* = ref object of RootObj
        root:Node

    Node = ref object of RootObj
        key:string
        value:int
        left:Node 
        right:Node 
        N:int

proc size_node(node:Node): int = 
    if node == nil:
        return 0
    else:
        return node.N
    
proc size*(bst:BST):int = 
    return size_node(bst.root)

proc get_node(node:Node, key:string): Option[int] = 
    if node == nil:
        return none(int)
    if key < node.key:
        return get_node(node.left, key)
    elif key > node.key:
        return get_node(node.right, key)
    else:
        return some(node.value)

proc get*(bst:BST, key:string): Option[int] =
    return get_node(bst.root, key)

proc put_node(node:Node, key:string, value:int):Node = 
    if node == nil:
        return Node(key:key, value:value, left:nil, right:nil, N:1)
    
    if key > node.key:
        node.right = put_node(node.right, key, value)
    elif key < node.key:
        node.left = put_node(node.left, key, value)
    else:
        node.value = value
    node.N = size_node(node.left) + size_node(node.right) + 1
    return node

proc put*(bst:BST, key:string, value:int) =
    bst.root = put_node(bst.root, key, value)

```