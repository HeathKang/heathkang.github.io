---
layout: post
title:  "排序"
subtitle: "常用排序算法"
date:   2018-10-17 18:00:05 -0400
background: '/img/posts/sort/sort.jpg'
categories: Programming
---
# 排序

## 排序算法

#### 1 选择排序
##### 思路
- 1 选择序列中最小的元素
- 2 将最小元素与序列首位交换
- 3 将序列右移一位重复上述操作直到序列移至最后一位

##### 实现

```
class Selection(Base):
    def sort(self, a: [Comparable]):
        for i in range(len(a)):
            min = i
            for j in range(i, len(a)):
                if self.less(a[j], a[min]):
                    min = j
                    
            self.exch(a, i, min)
``` 

具体代码可参考[selection.py](/examples/sort/selection.py)以及[base.py](/examples/sort/base.py)

#### 2 插入排序
##### 思路
- 1 将一个数字插入其他有序的数字中
- 2 适合于对非随机数组进行排序

##### 实现
```
class Insertion(Base):
    def sort(self, a:[Comparable]):
        for i in range(0, len(a)):
            for j in range(i):
                if self.less(a[i], a[j]):
                    self.exch(a, i, j)
```
具体代码可参考[selection.py](/examples/sort/insertion.py)以及[base.py](/examples/sort/base.py)

#### 3 冒泡排序
##### 思路
- 1 从左到右，每次相邻两个元素进行比较，小的向前，大的向后，这样最大的数就会到序列末端
- 2 剩余序列重复此过程，直到序列完结
- 3 因为每次都能排出剩余队列最大数字，就像水下泡泡不断冒出到末端一样，所以称为冒泡排序 = =！
##### 实现
```
class Bubble(Base):
    def sort(self, a:[Comparable]):
        for i in range(len(a)):
            for j in range(len(a) - i - 1):
                if self.less(a[j+1], a[j]):
                    self.exch(a, j, j+1)
```

具体代码可参考[bubble.py](/examples/sort/bubble.py)以及[base.py](/examples/sort/base.py)

#### 4 希尔排序
##### 思路
希尔排序是对插入排序的优化，因为插入排序在序列基本有序时会非常的快，所以我们可以将序列分为几个小序列进行排序，那么分为几组进行排序呢？一般我们用n/2的步长，来分割这个序列，直到1即初始序列，这样层层排序下来就是我们要得到的序列。
##### 实现
```
class Shell(Base):
    def sort(self, a:[Comparable]):
        # h为步长
        h = len(a) // 2
        while(h >=1):# 针对每一个步进做插入排序
            print("h{}".format(h))
            # 针对一个步进的每一个序列做插入排序
            for i in range(0, len(a)%h + 1): 
                
                # 针对每一个序列做插入排序
                for j in range(i, len(a), h):
                    for k in range(i, j, h):
                        print("i{}".format(i))
                        print("j{}".format(j))
                        print("k{}".format(k))
                        print(j-h*k)
                        if self.less(a[j], a[k]):
                            self.exch(a, j, k)
            h = h // 2 #直到步长为1
```

具体代码可参考[shell.py](/examples/sort/shell.py)以及[base.py](/examples/sort/base.py)

#### 5 归并排序
##### 思路
要将一个序列排序，可以递归地把它分为两半先排序，然后再将结果归并起来，形成一个有序序列。
##### 实现
```
class Merge(Base):
    def sort(self, a:[Comparable]):
        self.sort_individual(a, 0, len(a))

    def sort_individual(self, a:[Comparable], lo:int, hi:int):
        print("lo:{}".format(lo))
        print("hi:{}".format(hi))
        # 到极限情况
        if lo >= hi - 1:
            return

        mid = (hi - lo)//2 + lo
        self.sort_individual(a, lo, mid)
        self.sort_individual(a, mid, hi)
        self.merge(a, lo, hi, mid)

    def merge(self, a:[Comparable], lo:int, hi: int, mid: int):
        """
        归并 a[lo:mid] 和 a[mid: hi]
        """
        a_low:[Comparable] = deepcopy(a[lo:mid]) # 额外的空间
        a_high:[Comparable] = deepcopy(a[mid:hi]) # 额外的空间

        for i in range(lo,hi):
            if a_low and a_high: # 当a_low 和 a_high都非空时
                if self.less(a_high[0], a_low[0]):
                    a[i] = a_high[0]
                    a_high.pop(0)
                else:
                    a[i] = a_low[0]
                    a_low.pop(0)
            
            elif a_low: # 当a_high为空时
                a[i] = a_low[0]
                a_low.pop(0)
            
            elif a_high: # 当 a_low 为空时
                a[i] = a_high[0]
                a_high.pop(0)
```

具体代码可参考[merge.py](/examples/sort/merge.py)以及[base.py](/examples/sort/base.py)

##### 思考
以上实现是自上而下的归并方法，其实我们可以换个思路，自下而上进行归并，一归二，二归四。。。。最后合二为一。

#### 6 
##### 思路
一种分治的归并算法，将数组分为子数组，当子数组有序时，整个数组也就有序了。关键在于选出合适的切分位置。
- 关于切分算法，每次都取一个元素，将它的位置排定；
- 如何排定一个元素？假设这个元素在正确的位置，那从这个序列的两端向中间逼近，左边大于等于它的元素跟右端小于等于它的元素交换位置，最终两个指针相逢，那么这个位置就是这个元素的位置，因为元素左边的元素都小于等于它，右边的元素大于等于它（交换所得）。

##### 实现
```
class Quick(Base):
    def sort(self, a:[Comparable]):
        random.shuffle(a) # 让数组变得更加无序
        self.sort_individual(a, 0, len(a) - 1)

    def sort_individual(self, a:[Comparable], lo:int, hi:int):
        # 到极限情况
        if lo >= hi:
            return
        mid = self.partition(a, lo, hi)
        
        self.sort_individual(a, lo, mid-1)
        self.sort_individual(a, mid+1, hi)

    def partition(self, a:[Comparable], lo:int, hi: int) -> int:
        """
        切分a[lo]到这个序列的正确位置,并返回这个位置;
        """
        value: Comparable = a[lo]
        pos = lo # 记录初始位置
        lo = lo + 1 # 从下一位开始
        while(hi > lo):
            if self.less(a[hi], value) and self.less(value, a[lo]):# 右端元素<value，左端元素>=value，明显需要互换
                self.exch(a, lo, hi)
                lo = lo + 1
                hi = hi - 1
            elif not self.less(a[hi], value) and  self.less(value, a[lo]):# 右端元素>=value, 左端元素>=value，右边指针向左移动，左边指针等待
                hi = hi - 1
            elif self.less(a[hi], value) and not self.less(value, a[lo]):# 右端元素<value, 左端元素<value，右边指针等待，左边向右移动
                lo = lo + 1
            elif not self.less(a[hi], value) and not self.less(value, a[lo]):#右端元素>=value，左端元素<value，指针同时移动
                lo = lo + 1
                hi = hi - 1
            print("lo {}".format(lo))
            print("hi {}".format(hi))

        if hi == lo: # 指针落在中间一个元素上，需要区分这个元素>=还是<value
            if self.less(value, a[hi]):
                self.exch(a, pos, hi - 1)
                return hi - 1
            else:  
                self.exch(a, pos, hi)
                return hi
        else: # 指针移动交叉，这时指针位置hi<lo，a[hi]为较小元素的边界位置
            self.exch(a, pos, hi)
            return hi
```
具体代码可参考[quick.py](/examples/sort/quiclk.py)以及[base.py](/examples/sort/base.py)
